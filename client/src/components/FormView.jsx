import React, { useCallback, useEffect, useMemo, useState } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { getTableSchema, insertRow } from '../services/api';
import { editApp } from '../store/slices/appsSlice';

const numericTypes = new Set([
  'smallint',
  'integer',
  'bigint',
  'decimal',
  'numeric',
  'real',
  'double precision'
]);

const booleanTypes = new Set(['boolean']);

const dateTypes = new Set(['date']);

const dateTimeTypes = new Set([
  'timestamp without time zone',
  'timestamp with time zone'
]);

const sanitizeIdentifier = (value) => {
  if (!value) return '';
  if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(value)) {
    throw new Error('Invalid identifier in form configuration');
  }
  return value;
};

const isAutoGenerated = (schemaRow) => typeof schemaRow.column_default === 'string' && schemaRow.column_default.includes('nextval');

const fieldLabel = (column) => column.replace(/_/g, ' ').replace(/\b\w/g, letter => letter.toUpperCase());

const buildInitialFormState = (schema = []) =>
  schema.reduce((acc, column) => {
    if (isAutoGenerated(column)) return acc;
    if (booleanTypes.has(column.data_type)) {
      return { ...acc, [column.column_name]: false };
    }
    return { ...acc, [column.column_name]: '' };
  }, {});

const convertValue = (rawValue, column) => {
  if (rawValue === '' || rawValue === null || rawValue === undefined) return undefined;

  if (booleanTypes.has(column.data_type)) {
    return Boolean(rawValue);
  }

  if (numericTypes.has(column.data_type)) {
    const parsed = Number(rawValue);
    if (!Number.isFinite(parsed)) {
      throw new Error(`Column "${column.column_name}" expects a numeric value.`);
    }
    return parsed;
  }

  if (dateTypes.has(column.data_type)) {
    return rawValue;
  }

  if (dateTimeTypes.has(column.data_type)) {
    return rawValue ? new Date(rawValue).toISOString() : undefined;
  }

  return rawValue;
};

function FormView({ component, dbId }) {
  const dispatch = useDispatch();
  const { items: apps, activeAppId } = useSelector(state => state.apps);
  const tables = useSelector(state => state.data.tables);
  const app = apps.find(item => item.id === activeAppId);

  const [schema, setSchema] = useState([]);
  const [formState, setFormState] = useState({});
  const [loadingSchema, setLoadingSchema] = useState(false);
  const [submitStatus, setSubmitStatus] = useState('idle');
  const [error, setError] = useState('');
  const [successMessage, setSuccessMessage] = useState('');

  const config = component.config || {};
  const tableName = config.tableName || '';

  const updateComponentConfig = useCallback((updates) => {
    if (!app) return;
    const updatedComponents = (app.components || []).map(comp =>
      comp.id === component.id
        ? { ...comp, config: { ...comp.config, ...updates } }
        : comp
    );
    dispatch(editApp({ id: app.id, updates: { components: updatedComponents } }));
  }, [app, component.id, dispatch]);

  const loadSchema = useCallback(async () => {
    if (!dbId || !tableName) return;
    setLoadingSchema(true);
    setError('');
    try {
      sanitizeIdentifier(tableName);
      const response = await getTableSchema(dbId, tableName);
      setSchema(response || []);
      setFormState(buildInitialFormState(response));
    } catch (err) {
      setError(err?.response?.data?.message || err?.message || 'Failed to load table schema');
      setSchema([]);
      setFormState({});
    } finally {
      setLoadingSchema(false);
    }
  }, [dbId, tableName]);

  useEffect(() => {
    setSchema([]);
    setFormState({});
    if (dbId && tableName) {
      loadSchema();
    }
  }, [dbId, tableName, loadSchema]);

  const writableColumns = useMemo(() => schema.filter(col => !isAutoGenerated(col)), [schema]);

  const handleInputChange = (column, value) => {
    setFormState(prev => ({ ...prev, [column]: value }));
  };

  const handleCheckboxChange = (column, checked) => {
    setFormState(prev => ({ ...prev, [column]: checked }));
  };

  const handleSubmit = async (event) => {
    event.preventDefault();
    if (!dbId || !tableName) return;
    setSubmitStatus('loading');
    setError('');
    setSuccessMessage('');

    try {
      sanitizeIdentifier(tableName);
      const payload = {};

      for (const column of writableColumns) {
        const value = formState[column.column_name];
        const converted = convertValue(value, column);

        if (converted === undefined) {
          const hasDefault = Boolean(column.column_default);
          const optional = column.is_nullable === 'YES';
          if (!optional && !hasDefault) {
            throw new Error(`Column "${column.column_name}" is required.`);
          }
          continue;
        }

        payload[column.column_name] = converted;
      }

      await insertRow(dbId, tableName, payload);
      setSubmitStatus('succeeded');
      setSuccessMessage('Row inserted successfully.');
      setFormState(buildInitialFormState(schema));
    } catch (err) {
      setSubmitStatus('failed');
      setError(err?.response?.data?.message || err?.message || 'Failed to insert data');
    }
  };

  const renderInput = (column) => {
    const name = column.column_name;
    const value = formState[name];

    if (booleanTypes.has(column.data_type)) {
      return (
        <div className="form-group" key={name}>
          <label className="checkbox-label">
            <input
              type="checkbox"
              checked={Boolean(value)}
              onChange={(event) => handleCheckboxChange(name, event.target.checked)}
            />
            {fieldLabel(name)}
          </label>
        </div>
      );
    }

    let inputType = 'text';
    if (numericTypes.has(column.data_type)) inputType = 'number';
    else if (dateTypes.has(column.data_type)) inputType = 'date';
    else if (dateTimeTypes.has(column.data_type)) inputType = 'datetime-local';

    return (
      <div className="form-group" key={name}>
        <label>{fieldLabel(name)}</label>
        <input
          type={inputType}
          value={value ?? ''}
          onChange={(event) => handleInputChange(name, event.target.value)}
          placeholder={column.is_nullable === 'YES' || column.column_default ? 'Optional' : 'Required'}
        />
      </div>
    );
  };

  return (
    <div className="component form-view">
      <div className="component-config" style={{ marginBottom: '1rem' }}>
        <h4>Form Settings</h4>
        <div className="form-group">
          <label>Target Table</label>
          <select
            value={tableName}
            onChange={(event) => updateComponentConfig({ tableName: event.target.value || '' })}
          >
            <option value="">Select a table</option>
            {tables.map(table => (
              <option key={table} value={table}>{table}</option>
            ))}
          </select>
        </div>
      </div>

      {error && <div className="alert alert-error">{error}</div>}
      {successMessage && <div className="alert alert-success">{successMessage}</div>}

      {!tableName && <p>Select a table to start building a form.</p>}

      {tableName && loadingSchema && <div className="loading">Loading table schema...</div>}

      {tableName && !loadingSchema && schema.length === 0 && !error && (
        <div className="empty-state">
          <p>No schema information available for this table.</p>
        </div>
      )}

      {tableName && !loadingSchema && writableColumns.length > 0 && (
        <form onSubmit={handleSubmit} className="card" style={{ padding: '1.5rem' }}>
          <h3 style={{ marginBottom: '1rem' }}>New {tableName} Record</h3>
          <div className="form-grid">
            {writableColumns.map(renderInput)}
          </div>
          <div className="btn-group" style={{ marginTop: '1rem' }}>
            <button className="btn btn-primary" type="submit" disabled={submitStatus === 'loading'}>
              {submitStatus === 'loading' ? 'Saving...' : 'Insert Row'}
            </button>
            <button
              type="button"
              className="btn"
              onClick={() => {
                setFormState(buildInitialFormState(schema));
                setSuccessMessage('');
              }}
            >
              Reset
            </button>
          </div>
        </form>
      )}

      {tableName && !loadingSchema && writableColumns.length === 0 && !error && (
        <div className="empty-state">
          <p>No writable columns found for this table.</p>
        </div>
      )}
    </div>
  );
}

export default FormView;
